"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var api_exports = {};
__export(api_exports, {
  createProject: () => createProject,
  deploymentSelectionFromOptions: () => deploymentSelectionFromOptions,
  deploymentSelectionSchema: () => deploymentSelectionSchema,
  fetchDeploymentCredentialsForName: () => fetchDeploymentCredentialsForName,
  fetchDeploymentCredentialsProvisionProd: () => fetchDeploymentCredentialsProvisionProd,
  fetchDeploymentCredentialsProvisioningDevOrProdMaybeThrows: () => fetchDeploymentCredentialsProvisioningDevOrProdMaybeThrows,
  fetchDeploymentCredentialsWithinCurrentProject: () => fetchDeploymentCredentialsWithinCurrentProject,
  fetchTeamAndProject: () => fetchTeamAndProject,
  projectSelection: () => projectSelection,
  selfHostedCredentialsFromEnv: () => selfHostedCredentialsFromEnv,
  storeAdminKeyEnvVar: () => storeAdminKeyEnvVar
});
module.exports = __toCommonJS(api_exports);
var dotenv = __toESM(require("dotenv"), 1);
var import_context = require("../../bundler/context.js");
var import_deployment = require("./deployment.js");
var import_envvars = require("./envvars.js");
var import_run = require("./localDeployment/run.js");
var import_login = require("./login.js");
var import_utils = require("./utils/utils.js");
var import_zod = require("zod");
async function createProject(ctx, {
  teamSlug: selectedTeamSlug,
  projectName,
  partitionId,
  deploymentTypeToProvision
}) {
  const provisioningArgs = {
    team: selectedTeamSlug,
    projectName,
    // TODO: Consider allowing projects with no deployments, or consider switching
    // to provisioning prod on creation.
    deploymentType: deploymentTypeToProvision,
    partitionId
  };
  const data = await (0, import_utils.bigBrainAPI)({
    ctx,
    method: "POST",
    url: "create_project",
    data: provisioningArgs
  });
  const { projectSlug, teamSlug, projectsRemaining } = data;
  if (projectSlug === void 0 || teamSlug === void 0 || projectsRemaining === void 0) {
    const error = "Unexpected response during provisioning: " + JSON.stringify(data);
    return await ctx.crash({
      exitCode: 1,
      errorType: "transient",
      errForSentry: error,
      printedMessage: error
    });
  }
  return {
    projectSlug,
    teamSlug,
    projectsRemaining
  };
}
async function fetchDeploymentCredentialsForName(ctx, deploymentName, deploymentType) {
  let data;
  try {
    data = await (0, import_utils.bigBrainAPIMaybeThrows)({
      ctx,
      method: "POST",
      url: "deployment/authorize_for_name",
      data: {
        deploymentName,
        deploymentType
      }
    });
  } catch (error) {
    return { error };
  }
  const adminKey = data.adminKey;
  const url = data.url;
  const resultDeploymentType = data.deploymentType;
  if (adminKey === void 0 || url === void 0) {
    const msg = "Unknown error during authorization: " + JSON.stringify(data);
    return await ctx.crash({
      exitCode: 1,
      errorType: "transient",
      errForSentry: new Error(msg),
      printedMessage: msg
    });
  }
  return {
    deploymentName,
    adminKey,
    url,
    deploymentType: resultDeploymentType
  };
}
const deploymentSelectionSchema = import_zod.z.discriminatedUnion("kind", [
  import_zod.z.object({ kind: import_zod.z.literal("deployKey") }),
  import_zod.z.object({ kind: import_zod.z.literal("previewName"), previewName: import_zod.z.string() }),
  import_zod.z.object({ kind: import_zod.z.literal("deploymentName"), deploymentName: import_zod.z.string() }),
  import_zod.z.object({ kind: import_zod.z.literal("ownProd"), partitionId: import_zod.z.number().optional() }),
  import_zod.z.object({ kind: import_zod.z.literal("ownDev") }),
  import_zod.z.object({ kind: import_zod.z.literal("projectKey"), prod: import_zod.z.boolean() }),
  import_zod.z.object({
    kind: import_zod.z.literal("urlWithAdminKey"),
    url: import_zod.z.string(),
    adminKey: import_zod.z.string()
  }),
  import_zod.z.object({ kind: import_zod.z.literal("urlWithLogin"), url: import_zod.z.string() })
]);
function storeAdminKeyEnvVar(adminKeyOption) {
  if (adminKeyOption) {
    process.env[import_utils.CONVEX_DEPLOY_KEY_ENV_VAR_NAME] = adminKeyOption;
  }
}
async function deploymentSelectionFromOptions(ctx, options, extraCloudFlags = []) {
  if (options.envFile) {
    dotenv.config({ path: options.envFile });
  } else {
    dotenv.config({ path: import_utils.ENV_VAR_FILE_PATH });
    dotenv.config();
  }
  storeAdminKeyEnvVar(options.adminKey);
  const adminKey = (0, import_utils.readAdminKeyFromEnvVar)();
  const url = options.url;
  if (url !== void 0 && adminKey !== void 0) {
    return { kind: "urlWithAdminKey", url, adminKey };
  }
  const cloudFlags = [
    ["previewName", "--preview-name"],
    ["prod", "--prod"],
    ["deploymentName", "--deployment-name"],
    ...extraCloudFlags
  ];
  const selfHostedCredentials = await selfHostedCredentialsFromEnv(
    ctx,
    options,
    cloudFlags
  );
  if (selfHostedCredentials) {
    return {
      kind: "urlWithAdminKey",
      url: selfHostedCredentials.selfHostedUrl,
      adminKey: selfHostedCredentials.selfHostedAdminKey
    };
  }
  if (url !== void 0) {
    return { kind: "urlWithLogin", url };
  }
  if (options.previewName !== void 0) {
    return { kind: "previewName", previewName: options.previewName };
  }
  if (options.deploymentName !== void 0) {
    return { kind: "deploymentName", deploymentName: options.deploymentName };
  }
  const wantProd = options.prod === true || options.implicitProd === true;
  if (adminKey !== void 0) {
    if ((0, import_deployment.isProjectKey)(adminKey)) {
      return { kind: "projectKey", prod: wantProd };
    }
    return { kind: "deployKey" };
  }
  const partitionId = options.partitionId ? parseInt(options.partitionId) : void 0;
  return {
    kind: wantProd ? "ownProd" : "ownDev",
    partitionId
  };
}
async function selfHostedCredentialsFromEnv(ctx, options, cloudFlags) {
  if (options.envFile) {
    dotenv.config({ path: options.envFile });
  } else {
    dotenv.config({ path: import_utils.ENV_VAR_FILE_PATH });
    dotenv.config();
  }
  const selfHostedUrl = process.env[import_utils.CONVEX_SELF_HOSTED_URL_VAR_NAME];
  const selfHostedAdminKey = process.env[import_utils.CONVEX_SELF_HOSTED_ADMIN_KEY_VAR_NAME];
  if (!!selfHostedUrl !== !!selfHostedAdminKey) {
    return await ctx.crash({
      exitCode: 1,
      errorType: "fatal",
      printedMessage: `Env variables ${import_utils.CONVEX_SELF_HOSTED_URL_VAR_NAME} and ${import_utils.CONVEX_SELF_HOSTED_ADMIN_KEY_VAR_NAME} must be set together.`
    });
  }
  if (selfHostedUrl && selfHostedAdminKey) {
    const configuredDeployment = (0, import_deployment.getConfiguredDeploymentFromEnvVar)();
    if (configuredDeployment.name) {
      return await ctx.crash({
        exitCode: 1,
        errorType: "fatal",
        printedMessage: `Env variable ${import_utils.CONVEX_SELF_HOSTED_URL_VAR_NAME} indicates a self-hosted deployment, which is incompatible with cloud-hosted env variable ${import_deployment.CONVEX_DEPLOYMENT_VAR_NAME}. Remove one of them before running the command again.`
      });
    }
    for (const [flag, flagName] of cloudFlags) {
      if (options[flag]) {
        return await ctx.crash({
          exitCode: 1,
          errorType: "fatal",
          printedMessage: `Env variable ${import_utils.CONVEX_SELF_HOSTED_URL_VAR_NAME} indicates a self-hosted deployment, which is incompatible with cloud-hosted flag ${flagName}. Remove one of them before running the command again.`
        });
      }
    }
    return { selfHostedUrl, selfHostedAdminKey };
  }
  return void 0;
}
async function fetchDeploymentCredentialsWithinCurrentProject(ctx, deploymentSelection) {
  if (deploymentSelection.kind === "urlWithAdminKey") {
    return {
      adminKey: deploymentSelection.adminKey,
      url: deploymentSelection.url
    };
  }
  const configuredAdminKey = (0, import_utils.readAdminKeyFromEnvVar)();
  if (configuredAdminKey === void 0) {
    const buildEnvironmentExpectsConvexDeployKey = (0, import_envvars.buildEnvironment)();
    if (buildEnvironmentExpectsConvexDeployKey) {
      return await ctx.crash({
        exitCode: 1,
        errorType: "fatal",
        printedMessage: `${buildEnvironmentExpectsConvexDeployKey} build environment detected but ${import_utils.CONVEX_DEPLOY_KEY_ENV_VAR_NAME} is not set. Set this environment variable to deploy from this environment. See https://docs.convex.dev/production/hosting`
      });
    }
    const header = await (0, import_utils.getAuthHeaderForBigBrain)(ctx);
    if (!header) {
      return await ctx.crash({
        exitCode: 1,
        errorType: "fatal",
        printedMessage: `Error: You are not logged in. Log in with \`npx convex dev\` or set the ${import_utils.CONVEX_DEPLOY_KEY_ENV_VAR_NAME} environment variable. See https://docs.convex.dev/production/hosting`
      });
    }
    const configuredDeployment = (await (0, import_utils.getConfiguredDeployment)(ctx)).name;
    if (configuredDeployment === null) {
      return await ctx.crash({
        exitCode: 1,
        errorType: "fatal",
        printedMessage: "No CONVEX_DEPLOYMENT set, run `npx convex dev` to configure a Convex project"
      });
    }
  }
  const data = await fetchDeploymentCredentialsWithinCurrentProjectInner(
    ctx,
    deploymentSelection,
    configuredAdminKey
  );
  const { deploymentName, adminKey, deploymentType, url } = data;
  if (adminKey === void 0 || url === void 0 || deploymentName === void 0) {
    const msg = "Unknown error during authorization: " + JSON.stringify(data);
    return await ctx.crash({
      exitCode: 1,
      errorType: "transient",
      errForSentry: new Error(msg),
      printedMessage: msg
    });
  }
  return {
    deploymentName,
    adminKey,
    url,
    deploymentType
  };
}
async function projectSelection(ctx, configuredDeployment, configuredAdminKey) {
  if (configuredAdminKey !== void 0 && (0, import_deployment.isPreviewDeployKey)(configuredAdminKey)) {
    const { teamSlug, projectSlug } = await (0, import_deployment.getTeamAndProjectFromPreviewAdminKey)(ctx, configuredAdminKey);
    return {
      kind: "teamAndProjectSlugs",
      teamSlug,
      projectSlug
    };
  }
  if (configuredAdminKey !== void 0) {
    return {
      kind: "deploymentName",
      deploymentName: await (0, import_deployment.deploymentNameFromAdminKeyOrCrash)(
        ctx,
        configuredAdminKey
      )
    };
  }
  if (configuredDeployment) {
    return {
      kind: "deploymentName",
      deploymentName: configuredDeployment
    };
  }
  return await ctx.crash({
    exitCode: 1,
    errorType: "fatal",
    printedMessage: "Select project by setting `CONVEX_DEPLOYMENT` with `npx convex dev` or `CONVEX_DEPLOY_KEY` from the Convex dashboard."
  });
}
async function fetchDeploymentCredentialsWithinCurrentProjectInner(ctx, deploymentSelection, configuredAdminKey) {
  const configuredDeployment = (0, import_deployment.getConfiguredDeploymentFromEnvVar)().name;
  switch (deploymentSelection.kind) {
    case "ownDev": {
      return {
        ...await fetchExistingDevDeploymentCredentialsOrCrash(
          ctx,
          configuredDeployment
        ),
        deploymentName: configuredDeployment
      };
    }
    case "ownProd":
      return await (0, import_utils.bigBrainAPI)({
        ctx,
        method: "POST",
        url: "deployment/authorize_prod",
        data: {
          deploymentName: configuredDeployment,
          partitionId: deploymentSelection.partitionId
        }
      });
    case "previewName":
      return await (0, import_utils.bigBrainAPI)({
        ctx,
        method: "POST",
        url: "deployment/authorize_preview",
        data: {
          previewName: deploymentSelection.previewName,
          projectSelection: await projectSelection(
            ctx,
            configuredDeployment,
            configuredAdminKey
          )
        }
      });
    case "deploymentName":
      return await (0, import_utils.bigBrainAPI)({
        ctx,
        method: "POST",
        url: "deployment/authorize_within_current_project",
        data: {
          selectedDeploymentName: deploymentSelection.deploymentName,
          projectSelection: await projectSelection(
            ctx,
            configuredDeployment,
            configuredAdminKey
          )
        }
      });
    case "deployKey": {
      const deploymentName = await (0, import_deployment.deploymentNameFromAdminKeyOrCrash)(
        ctx,
        configuredAdminKey
      );
      let url = await deriveUrlFromAdminKey(ctx, configuredAdminKey);
      if (process.env.CONVEX_PROVISION_HOST !== void 0) {
        url = await (0, import_utils.bigBrainAPI)({
          ctx,
          method: "POST",
          url: "deployment/url_for_key",
          data: {
            deployKey: configuredAdminKey
          }
        });
      }
      const deploymentType = (0, import_deployment.deploymentTypeFromAdminKey)(configuredAdminKey);
      return {
        adminKey: configuredAdminKey,
        url,
        deploymentName,
        deploymentType
      };
    }
    case "projectKey": {
      const deploymentType = deploymentSelection.prod ? "prod" : "dev";
      const credentials = await fetchDeploymentCredentialsProvisioningDevOrProdMaybeThrows(
        ctx,
        { teamSlug: null, projectSlug: null },
        deploymentType,
        void 0
      );
      return {
        adminKey: credentials.adminKey,
        url: credentials.deploymentUrl,
        deploymentName: credentials.deploymentName,
        deploymentType
      };
    }
    case "urlWithLogin":
      return {
        ...await (0, import_utils.bigBrainAPI)({
          ctx,
          method: "POST",
          url: "deployment/authorize_within_current_project",
          data: {
            selectedDeploymentName: configuredDeployment,
            projectSelection: await projectSelection(
              ctx,
              configuredDeployment,
              configuredAdminKey
            )
          }
        }),
        url: deploymentSelection.url
      };
    default: {
      const _exhaustivenessCheck = deploymentSelection;
      return ctx.crash({
        exitCode: 1,
        errorType: "fatal",
        // This should be unreachable, so don't bother with a printed message.
        printedMessage: null,
        errForSentry: `Unexpected deployment selection: ${deploymentSelection}`
      });
    }
  }
}
async function fetchDeploymentCredentialsProvisionProd(ctx, deploymentSelection, { ensureLocalRunning } = { ensureLocalRunning: true }) {
  if (deploymentSelection.kind === "ownDev" && !await (0, import_login.checkAuthorization)(ctx, false)) {
    await (0, import_login.performLogin)(ctx);
  }
  if (deploymentSelection.kind !== "ownDev") {
    const result2 = await fetchDeploymentCredentialsWithinCurrentProject(
      ctx,
      deploymentSelection
    );
    (0, import_context.logVerbose)(
      ctx,
      `Deployment URL: ${result2.url}, Deployment Name: ${result2.deploymentName}, Deployment Type: ${result2.deploymentType}`
    );
    return {
      url: result2.url,
      adminKey: result2.adminKey,
      deploymentName: result2.deploymentName,
      deploymentType: result2.deploymentType
    };
  }
  const configuredDeployment = await (0, import_utils.getConfiguredDeploymentNameOrCrash)(ctx);
  const result = await fetchExistingDevDeploymentCredentialsOrCrash(
    ctx,
    configuredDeployment
  );
  (0, import_context.logVerbose)(
    ctx,
    `Deployment URL: ${result.url}, Deployment Name: ${configuredDeployment}, Deployment Type: ${result.deploymentType}`
  );
  if (ensureLocalRunning && configuredDeployment?.startsWith("local-")) {
    await (0, import_run.assertLocalBackendRunning)(ctx, {
      url: result.url,
      deploymentName: configuredDeployment
    });
  }
  return {
    url: result.url,
    adminKey: result.adminKey,
    deploymentType: result.deploymentType,
    deploymentName: configuredDeployment
  };
}
async function fetchTeamAndProject(ctx, deploymentName) {
  const data = await (0, import_utils.bigBrainAPI)({
    ctx,
    method: "GET",
    url: `deployment/${deploymentName}/team_and_project`
  });
  const { team, project } = data;
  if (team === void 0 || project === void 0) {
    const msg = "Unknown error when fetching team and project: " + JSON.stringify(data);
    return await ctx.crash({
      exitCode: 1,
      errorType: "transient",
      errForSentry: new Error(msg),
      printedMessage: msg
    });
  }
  return data;
}
async function fetchDeploymentCredentialsProvisioningDevOrProdMaybeThrows(ctx, {
  teamSlug,
  projectSlug
}, deploymentType, partitionId) {
  const data = await (0, import_utils.bigBrainAPIMaybeThrows)({
    ctx,
    method: "POST",
    url: "deployment/provision_and_authorize",
    data: {
      teamSlug,
      projectSlug,
      deploymentType,
      partitionId
    }
  });
  const deploymentName = data.deploymentName;
  const adminKey = data.adminKey;
  const url = data.url;
  if (adminKey === void 0 || url === void 0) {
    const msg = "Unknown error during authorization: " + JSON.stringify(data);
    return await ctx.crash({
      exitCode: 1,
      errorType: "transient",
      errForSentry: new Error(msg),
      printedMessage: msg
    });
  }
  return { adminKey, deploymentUrl: url, deploymentName };
}
function credentialsAsDevCredentials(cred) {
  if (cred.deploymentType === "dev") {
    return cred;
  }
  throw new Error("Credentials are not for a dev deployment.");
}
async function fetchExistingDevDeploymentCredentialsOrCrash(ctx, deploymentName) {
  const credentials = await fetchDeploymentCredentialsForName(
    ctx,
    deploymentName,
    "dev"
  );
  if ("error" in credentials) {
    return await ctx.crash({
      exitCode: 1,
      errorType: "invalid filesystem data",
      errForSentry: credentials.error,
      printedMessage: `Failed to authorize "${deploymentName}" configured in CONVEX_DEPLOYMENT, run \`npx convex dev\` to configure a Convex project`
    });
  }
  if (credentials.deploymentType !== "dev") {
    return await ctx.crash({
      exitCode: 1,
      errorType: "invalid filesystem data",
      printedMessage: `Deployment "${deploymentName}" is not a dev deployment`
    });
  }
  return credentialsAsDevCredentials(credentials);
}
async function deriveUrlFromAdminKey(ctx, adminKey) {
  const deploymentName = await (0, import_deployment.deploymentNameFromAdminKeyOrCrash)(ctx, adminKey);
  return `https://${deploymentName}.convex.cloud`;
}
//# sourceMappingURL=api.js.map
